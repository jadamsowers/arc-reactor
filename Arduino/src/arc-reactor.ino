#include <Adafruit_NeoPixel.h>

#ifdef __AVR_ATtiny85__ // Trinket, Gemma, etc.
 #include <avr/power.h>
#endif

// pin where you connected the NeoPixel ring DataIn pin
const uint8_t PIN = 1;

// 24 for the ring, 7 for the disc
const uint8_t LEDs = 31;

// scale this down if you're using transparent plastic
const uint8_t maxBrightness = 255;

// initial delay between pixel shift during startup
const uint8_t delay_ms_init = 25;


Adafruit_NeoPixel pixels = Adafruit_NeoPixel(LEDs, PIN);

/* this array generated by breathe.py
using LED 'breathing' function by Sean Voisen.
http://sean.voisen.org/blog/2011/10/breathing-led-with-arduino/ */
const uint8_t numSteps = 128;
const uint32_t breath[numSteps] PROGMEM = {
  0x000000, 0x000000, 0x000000, 0x000000, 0x000101, 0x000102, 0x000203, 0x010304,
  0x010405, 0x010507, 0x020708, 0x02080A, 0x030A0C, 0x030B0E, 0x040D10, 0x040F13,
  0x051115, 0x061318, 0x06161A, 0x07181D, 0x081A20, 0x091D23, 0x091F27, 0x0A222A,
  0x0B252D, 0x0C2831, 0x0D2A34, 0x0E2D38, 0x0F303B, 0x0F333F, 0x103643, 0x113947,
  0x123D4A, 0x13404E, 0x144352, 0x154656, 0x16495A, 0x174C5E, 0x184F62, 0x195365,
  0x1A5669, 0x1B596D, 0x1C5C71, 0x1D5F75, 0x1E6279, 0x1F657C, 0x206880, 0x216B84,
  0x226E87, 0x22718B, 0x23748E, 0x247792, 0x257A95, 0x267D99, 0x277F9C, 0x28829F,

  0x2884A3, 0x2987A6, 0x2A8AA9, 0x2B8CAC, 0x2B8EAF, 0x2C91B2, 0x2D93B4, 0x2E95B7,
  0x2E98BA, 0x2F9ABD, 0x309CBF, 0x309EC2, 0x31A0C4, 0x31A2C6, 0x32A4C9, 0x33A5CB,
  0x33A7CD, 0x34A9CF, 0x34ABD1, 0x35ACD3, 0x35AED5, 0x36AFD7, 0x36B1D9, 0x37B2DB,
  0x37B4DC, 0x37B5DE, 0x38B6E0, 0x38B8E1, 0x39B9E3, 0x39BAE4, 0x39BBE6, 0x3ABCE7,
  0x3ABDE8, 0x3ABEE9, 0x3BBFEB, 0x3BC0EC, 0x3BC1ED, 0x3BC2EE, 0x3CC3EF, 0x3CC4F0,
  0x3CC4F1, 0x3CC5F2, 0x3DC6F3, 0x3DC7F4, 0x3DC7F4, 0x3DC8F5, 0x3DC8F6, 0x3DC9F7,
  0x3ECAF7, 0x3ECAF8, 0x3ECBF8, 0x3ECBF9, 0x3ECBF9, 0x3ECCFA, 0x3ECCFA, 0x3FCDFB,
  0x3FCDFB, 0x3FCDFC, 0x3FCEFC, 0x3FCEFC, 0x3FCEFD, 0x3FCEFD, 0x3FCFFD, 0x3FCFFE,
  0x3FCFFE, 0x3FCFFE, 0x3FCFFE, 0x3FCFFE, 0x3FCFFE, 0x3FCFFE, 0x3FCFFE, 0x3FCFFE
};

void setup()
{
  #ifdef __AVR_ATtiny85__ // Trinket, Gemma, etc.
    if(F_CPU == 16000000) clock_prescale_set(clock_div_1);
  #endif

  pixels.begin();
  pixels.setBrightness(maxBrightness);
}

void startup()
{
  uint8_t i;
  uint8_t delay_ms = delay_ms_init;
  uint8_t scale = numSteps / delay_ms_init;

  while(delay_ms > 0)
  {

    uint32_t color = pgm_read_dword(
      breath + ( (delay_ms_init - delay_ms) * scale ) );

    // always keep the center LED on.
    pixels.setPixelColor(24, color);

    for(i = 0; i < 24; i++)
    {
      //rotate clockwise on the ring.
      pixels.setPixelColor(i, color);

      //rotate counterclockwise in the center.
      pixels.setPixelColor(30 - (i % 6), color);

      pixels.show();
      delay(delay_ms);
      pixels.clear();
    }

    delay_ms--;
  }

  // full on brightness for a few seconds
  for(i = 0; i < 31; i++)
  {
    pixels.setPixelColor(i, pgm_read_dword(breath + numSteps - 1));
  }
  pixels.show();
  delay(3000);
}

void breathe()
{
  // assuming all lights are on already
  uint8_t i,j;
  int8_t direction = -1;

  while(true)
  {
    // loop over all the values in the array
    for(i = 0; i < numSteps; i++)
    {
      // loop over all the pixels in the ring (disc pixels stay constant)
      for(j = 0; j < 24; j++)
      {
        uint32_t color = direction == 1 ?
          pgm_read_dword(breath + i) :
          pgm_read_dword(breath + numSteps - i - 1);

        pixels.setPixelColor(j, color);
      }
      pixels.show();
      delay(delay_ms_init);

    }
    direction *= -1;
  }
}

void loop()
{
  startup();
  breathe();
}
