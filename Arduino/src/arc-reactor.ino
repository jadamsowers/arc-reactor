#include <Adafruit_NeoPixel.h>

#ifdef __AVR_ATtiny85__ // Trinket, Gemma, etc.
 #include <avr/power.h>
#endif

// pin where you connected the NeoPixel ring DataIn pin
const uint8_t PIN = 1;

// 24 for the ring, 7 for the disc
const uint8_t LEDs = 31;

// scale this down if you're using transparent plastic
const uint8_t maxBrightness = 255;

// initial delay between pixel shift during startup
const uint8_t delay_ms_init = 25;


Adafruit_NeoPixel pixels = Adafruit_NeoPixel(LEDs, PIN);

/* this array generated by breathe.py
using LED 'breathing' function by Sean Voisen.
http://sean.voisen.org/blog/2011/10/breathing-led-with-arduino/ */
const uint8_t numSteps = 128;
const uint32_t breath[numSteps] PROGMEM = {
  0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000,
  0x000000, 0x000000, 0x000001, 0x000101, 0x000101, 0x000102, 0x000102, 0x000202,
  0x000203, 0x000203, 0x010304, 0x010304, 0x010405, 0x010405, 0x010406, 0x010506,
  0x010507, 0x020607, 0x020708, 0x020709, 0x02080A, 0x02080A, 0x02090B, 0x030A0C,
  0x030B0D, 0x030B0E, 0x030C0F, 0x040D10, 0x040E11, 0x040F12, 0x041013, 0x051115,
  0x051216, 0x051317, 0x061418, 0x06151A, 0x06161B, 0x07171D, 0x07191E, 0x081A20,
  0x081B22, 0x081D23, 0x091E25, 0x092027, 0x0A2129, 0x0A232B, 0x0B242D, 0x0B262F,
  0x0C2831, 0x0C2A33, 0x0D2B35, 0x0E2D38, 0x0E2F3A, 0x0F313C, 0x0F333F, 0x103541,
  0x113744, 0x113A47, 0x123C4A, 0x133E4C, 0x14414F, 0x144352, 0x154555, 0x164858,
  0x174B5B, 0x174D5F, 0x185062, 0x195265, 0x1A5569, 0x1B586C, 0x1C5B70, 0x1D5E73,
  0x1D6177, 0x1E647A, 0x1F677E, 0x206A82, 0x216D85, 0x227089, 0x23738D, 0x247691,
  0x257995, 0x267C99, 0x27809C, 0x2883A0, 0x2986A4, 0x2A89A8, 0x2B8CAC, 0x2C8FB0,
  0x2D92B4, 0x2E96B7, 0x2F99BB, 0x309CBF, 0x309FC3, 0x31A2C6, 0x32A5CA, 0x33A7CD,
  0x34AAD1, 0x35ADD4, 0x36B0D7, 0x36B2DB, 0x37B5DE, 0x38B7E1, 0x39B9E4, 0x39BCE6,
  0x3ABEE9, 0x3BC0EB, 0x3BC2EE, 0x3CC4F0, 0x3CC5F2, 0x3DC7F4, 0x3DC8F6, 0x3ECAF7,
  0x3ECBF9, 0x3ECCFA, 0x3FCDFB, 0x3FCEFC, 0x3FCEFD, 0x3FCFFE, 0x3FCFFE, 0x3FCFFE
};

void setup()
{
  #ifdef __AVR_ATtiny85__ // Trinket, Gemma, etc.
    if(F_CPU == 16000000) clock_prescale_set(clock_div_1);
  #endif

  pixels.begin();
  pixels.setBrightness(maxBrightness);
}

void startup()
{
  uint8_t i;
  uint8_t delay_ms = delay_ms_init;
  uint8_t scale = numSteps / delay_ms_init;

  while(delay_ms > 0)
  {

    uint32_t color = pgm_read_dword(
      breath + ( (delay_ms_init - delay_ms) * scale ) );

    // always keep the center LED on.
    pixels.setPixelColor(24, color);

    for(i = 0; i < 24; i++)
    {
      //rotate clockwise on the ring.
      pixels.setPixelColor(i, color);

      //rotate counterclockwise in the center.
      pixels.setPixelColor(30 - (i % 6), color);

      pixels.show();
      delay(delay_ms);
      pixels.clear();
    }

    delay_ms--;
  }

  // full on brightness for a few seconds
  for(i = 0; i < 31; i++)
  {
    pixels.setPixelColor(i, pgm_read_dword(breath + numSteps - 1));
  }
  pixels.show();
  delay(3000);
}

void breathe()
{
  // assuming all lights are on already
  uint8_t i,j;
  int8_t direction = -1;

  while(true)
  {
    // loop over all the values in the array
    for(i = 0; i < numSteps; i++)
    {
      // loop over all the pixels in the ring (disc pixels stay constant)
      for(j = 0; j < 24; j++)
      {
        uint32_t color = direction == 1 ?
          pgm_read_dword(breath + i) :
          pgm_read_dword(breath + numSteps - i - 1);

        pixels.setPixelColor(j, color);
      }
      pixels.show();
      delay(15);

    }
    direction *= -1;
  }
}

void loop()
{
  startup();
  breathe();
}
